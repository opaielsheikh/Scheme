#lang racket

;; some soduku puzzles, in a list form (_ indicates empty)

(define puzzle
     '( (_ _ _ 2 6 _ 7 _ 1)
	(6 8 _ _ 7 _ _ 9 _)
	(1 9 _ _ _ 4 5 _ _)
	(8 2 _ 1 _ _ _ 4 _)
	(_ _ 4 6 _ 2 9 _ _)
	(_ 5 _ _ _ 3 _ 2 8)
	(_ _ 9 3 _ _ _ 7 4)
	(_ 4 _ _ 5 _ _ 3 6)
	(7 _ 3 _ 1 8 _ _ _)  )
)

(define hardPuzzle
    '(  (7 3 _ 1 _ _ 9 _ _)
	(_ _ 4 _ _ _ 2 3 _)
	(_ _ _ 3 _ _ _ 5 _)
	(9 _ _ _ _ _ 3 _ _)
	(_ _ 5 _ _ _ 6 2 _)
	(_ _ _ _ _ _ _ 8 4)
	(2 _ _ _ 4 1 _ _ _)
	(8 _ _ _ 9 _ _ _ _)
	(1 _ _ _ 8 5 _ _ 2)  )
)

(define hardestPuzzle
    '(  (8 _ _ _ _ _ _ _ _)
        (_ _ 3 6 _ _ _ _ _)
        (_ 7 _ _ 9 _ 2 _ _)
        (_ 5 _ _ _ 7 _ _ _)
        (_ _ _ _ 4 5 7 _ _)
        (_ _ _ 1 _ _ _ 3 _)
        (_ _ 1 _ _ _ _ 6 8)
        (_ _ 8 5 _ _ _ 1 _)
        (_ 9 _ _ _ _ 4 _ _) )
)

;; this has no solution; and it takes a long time to demonstrate that!
(define impossiblePuzzle
  '(    (_ _ _ _ _ 5 _ 8 _)
        (_ _ _ 6 _ 1 _ 4 3)
        (_ _ _ _ _ _ _ _ _)
        (_ 1 _ 5 _ _ _ _ _)
        (_ _ _ 1 _ 6 _ _ _)
        (3 _ _ _ _ _ _ _ 5)
        (5 3 _ _ _ _ _ 6 1)
        (_ _ _ _ _ _ _ _ 4)
        (_ _ _ _ _ _ _ _ _)))


;; general variables for the problem

(define gridSize 9)
(define boxSize  3)
(define Symbols '(1 2 3 4 5 6 7 8 9))
(define emptySymbol '_)

;;   SOLVING THE PROBLEM
;;   I begin by identifying important variables in the problem, and trying to state
;;   the problem in a way that specifically describes these variables.
;;
;;   I start by asking: what variables are important in soduku?  How can I identify
;;   and represent those variables?  The first thing that strikes me is that
;;   individual cells in a soduku grid have 4 important variables: row number, column number,
;;   the (3x3) "box" they are in, and the value they contain (or the possible values
;;   they could contain).  I'll need to use all these variables when solving the puzzle.

;;   I'll start solving the problem by coming up with a way of converting a soduku puzzle
;;   in the list form shown above into a "cell" representation that holds these
;;   important values for each cell: this will make it easier to work on the problem.
;;
;; assuming that cells are indexed in increasing order from 0 (running across the
;; soduku grid and from row to row) this function "cell" takes a cell number N and
;; a cell value V, and makes a cell representation of the form (value columnNumber rowNumber boxNumber).
;; the value here can either be the list of all Symbols, indicating any number may possibly be in
;; that cell, or a list with a single value (the value for that cell that has been set in the problem).

(define cell
  (lambda (N V)    
    (list (if (equal? V emptySymbol) Symbols (list V))             ;; list of possible values for cell
          (remainder N gridSize)                                   ;; column number for cell
          (truncate (/ N gridSize))                                ;; row number  for cell
          (+ (* boxSize (truncate (/ (remainder N gridSize) boxSize)))
             (truncate (/ (truncate (/ N gridSize)) boxSize)))     ;;  "box" number for cell
)))


;; here are functions that return different properties of a given cell
(define vals car)
(define firstval caar)
(define col cadr)
(define row caddr)
(define box cadddr) 

;;  function "cells" generates a representation for every cell, given an initial
;; puzzle list which we assume is just a list of symbols (with _ to show a cell is empty).
;; for one of the puzzles above, this list is generated by (apply append puzzle) or (flatten puzzle)

(define cells (lambda(N L) (if (null? L) '() (cons (cell N (car L)) (cells (+ N 1) (cdr L))))))

;; It would also be useful to have a function that takes a list of cells, and converts it
;; back into the 9x9 list "grid display" format.  This function grid does this.
(define grid
  (lambda(N L) 
    (if (= N gridSize) '() (cons (map car (map vals (sort (filter (lambda(X) (= (row X) N)) L)
                                                         (lambda(X Y) (< (col X) (col Y))))))
                                  (grid (+ N 1) L)) )))

;; once we have this "cell" representation of a soduku puzzle, we can do some useful things.
;; The first thing we should think of is a way of checking whether a given finished puzzle
;; actually satisfies the rules of soduku.   This check function does that by, for each
;; number N from 0 to gridsize, getting all values in row N, column N and box N, and
;; checking if those values are equal to the full list of symbols (so each symbol occurs once).
;;  I use "filter" to pick out the cells I'm interested in, map caar to extract the values of those
;; cells, and the built-in function sort to put them in sorted order for comparison.

(define check
  (lambda(N P)
    (cond [ (= N gridSize)                                                                    #t ]
          [ (not (equal? Symbols (sort (map caar (filter (lambda(X) (= (col X) N)) P )) <)))  #f ]
          [ (not (equal? Symbols (sort (map caar (filter (lambda(X) (= (row X) N)) P )) <)))  #f ]
          [ (not (equal? Symbols (sort (map caar (filter (lambda(X) (= (box X) N)) P )) <)))  #f ]
          [ #t                                                                 (check (+ N 1) P) ]
 )))


;;  I can also make some useful actions that will probably be part of solving a soduku problem, for example:

;; remove the fixed value in cell F from the set of possible values of cell C, returning the updated C
(define removeVal (lambda(F C) (cons (remove (firstval F) (vals C)) (cdr C))))

;; given a cell C, return an updated cell C holding only its first value ("fix" that value for the cell)
(define fixVal (lambda(C) (cons (list (firstval C)) (cdr C))))

;; given a cell C, return an updated cell C holding all but its first value:
(define restvals (lambda(C) (cons  (cdr (vals C)) (cdr C))))

;; take a cell C and the list of other cells F whose values have been found, and return
;; the cell C updated with the reduced list of allowable values for C under the rules of
;; Soduku (removing all possible values in C that "clash" with values in cells in F that are
;; in the same row, column or box as C).
(define reduceVals
  (lambda (C F) 
    (cond [ (null? F)                              C                                     ] 
          [ (or (= (col C) (col (car F)))
                (= (row C) (row (car F)))
                (= (box C) (box (car F))))   (reduceVals (removeVal (car F) C) (cdr F))   ]
          [   #t                             (reduceVals C (cdr F))                       ]
 )))

;; reduce all cells in a problem P, relative to a set of other cells F whose values have been found.
;; returns the cells sorted in increasing order of "difficulty" (easiest cells first).
(define reduce (lambda(F P)  (sortCells (map (lambda(X)(reduceVals X F)) P) )))

;; this sort uses scheme's built-in sort function (which takes a list and a comparison function
;;  Here I'm comparing lengths of possible values, so that "easiest" cells come first.

(define sortCells (lambda(P) (sort P (lambda(X Y)  (< (length (vals X))(length (vals Y)))))))



;;  USING THESE TOOLS TO SOLVE SODUKU PUZZLES
;;
;;  Given this representation and these tools, we are ready to derive a recursive algorithm
;; for solving a soduku puzzle.
;;
;; What variables are important here?  There are two types of cells: those
;; whose values have been "fixed" or filled-in (call these F) and those whose
;; values still haven't been found (the problem cells, P).  So our "solve" function is going to
;; have two inputs, a list of cells F and a list of cells P.  
;; Base cases are:
;; 1) if the problem list P is empty, return the list of filled-in cells F: the problem is solved.
;; 2) if the current problem cell (car P) has no possible values that can be assigned to it
;;    (if it's vals variable is an empty list), there is no solution possible  with the given
;      set of found values F: in this case return '().
;; recursive case:
;;   try solving the rest of the problem (cdr P) by fixing the first value of the
;;   current cell (car P) (producing an updated list F containing that fixed value)
;;   and then reducing the remaining problem (cdr P) (removing all values that clash with
;;   that new list F).   Recursively call "solve" for that new F and that reduced version of (cdr P).
;;   If that recursive call gives a solution, the problem is solved.
;;   If that doesn't give a solution, then the first value of (car P) doesn't work: so instead
;;   recursively call "solve" with the same set of fixed values F, and the same problem P,
;;   but with that first value removed from the (car P) cell in P.

(define solve
  (lambda (F P)     
    (cond [ (null? P)                                                 F               ]
          [ (null? (vals (car P)))                                   '()              ] 
          [ #t     (define S (solve (cons (fixVal (car P)) F)         
                                    (reduce (cons (fixVal (car P)) F) (cdr P))))                                     
                   (if (not (null? S)) S (solve F (cons (restvals (car P)) (cdr P)))) ]
)))            

;; and that's the soduku solver.  To run it, we set up the initial cell representation,
;;  and then call solve, using grid to make the returned solution into a 9x9 solution grid

(define solveSoduku 
   (lambda(L)     
       (define solution (solve '() (sortCells (cells 0 (apply append L)))))
       (if (check 0 solution) (grid 0 solution ) '())
 ))  



;; solve the puzzles
 (define s1 (solveSoduku puzzle)) s1
;; (define s2 (solveSoduku hardPuzzle)) s2 
;; (define s3 (solveSoduku hardestPuzzle)) s3
;; (define s4 (solveSoduku impossiblePuzzle)) s4
